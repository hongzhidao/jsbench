# 功能没变，但引擎造好了

上一篇把事件引擎封装成了一行 `js_epoll_poll(100)`。这一篇处理另一个基础设施：定时器。

但这个 100——`epoll_wait()` 的超时参数——恰恰是问题所在。它是写死的。无论最近的定时器是 5 毫秒还是 5 秒后到期，事件循环都固定等 100 毫秒再去看。定时器说"5 毫秒后叫我"，事件循环回答"我 100 毫秒后才有空"。

要解决这个问题，需要重新设计定时器。而重新设计定时器之前，需要先打地基。

这篇只做地基的事——引入红黑树、时间基础函数、和独立的定时器模块。还没有改动任何现有的定时器逻辑。听起来像是"什么都没干"，但这恰恰是最重要的一步。

## 当前的定时器：三种方式，同一件事

先说问题。

jsbench 有三种完全不同的定时器机制。C-path 用操作系统提供的定时器文件描述符，时间到了 epoll 收到事件。JS-path 在每次循环开头手动取当前时间，跟截止时间比较，到了就退。请求超时在事件循环里——每轮遍历所有 pending 请求，逐个检查。

三种方式做的是同一件事："等一段时间，然后做点什么"。但实现方式完全不同，互不知道对方的存在。

想统一它们，需要一个通用的定时器模块。但定时器模块不是凭空就能写出来的——它需要数据结构、时间类型、语言工具这些基础设施。**你不能在沙地上盖房子。**

## 为什么先打地基

不熟悉编程的读者可以这样理解。

假设你要装修厨房。最终目标是一个能做饭的厨房。但你不能第一天就买灶台——你得先确认水管接好了、电线拉好了、墙面是平的。这些事没人看得到，装完之后也感觉不到它们的存在。但没有它们，灶台装不上去，装上去了也不能用。

基础设施就是这样：**用的时候感觉不到它的存在，缺的时候什么都做不了。**

更重要的是，基础设施决定了上层能做什么、做到什么程度。如果水管只有冷水，你就装不了热水龙头。如果时间类型没有封装好，定时器模块写出来就到处是原始的系统调用，跟现在没区别。**地基的质量决定了房子的上限。**

很多人在这个时候会急着写功能——"先把三种定时器统一了再说，基础设施边做边补"。这种做法不是不行，但通常的结果是：功能写到一半发现缺的东西太多，回头补的时候又发现已经写好的功能和新补的基础设施对不上，来来回回改。**先打地基看起来慢，但总路程最短。**

所以这次的改动只做一件事：把地基打好。不急着统一三种定时器——那是下一步的事。

## 选择数据结构：红黑树

定时器要做三件事：添加（"x 毫秒后叫我"）、删除（"不用了，请求已经完成了"）、找最近的（"下一个要响的闹钟是几点"）。

这需要一个数据结构。

想象你管理一堆待办事项，每件有截止时间。你需要随时知道哪件最紧急，能快速加新的，也能在完成后快速划掉。

**最简单的方法：一摞纸随便堆。** 找最紧急的？把整摞翻一遍。这就是当前请求超时的做法——每轮循环遍历所有 pending 请求。

**红黑树：一个自动排序的文件柜。** 放进去的时候自动排好，最紧急的永远在最前面。加一件、删一件、看最前面是什么——每个操作都很快。100 个待办最多比较 7 次，1000 个最多 10 次，65536 个最多 16 次。

还有一种常见选择叫最小堆——看最前面只要 1 次，加一件也很快。但有个问题：如果你要划掉的不是最前面那件（比如某个请求提前完成了，要取消它的超时），最小堆得先在一大堆里找到它。红黑树不存在这个问题——你手上拿着那件待办的引用，直接划掉。

**红黑树在三个操作上没有短板。** 对于定时器管理来说，这是最均衡的选择。

这就是一个典型的选型判断。AI 会建议你用最小堆——在大多数教科书里，定时器管理确实用最小堆。但教科书的场景通常不需要频繁删除任意节点。jsbench 需要——请求完成时要取消超时定时器，连接关闭时要取消空闲定时器。**选型不是选"最常见的"，而是选"最适合你的场景的"。** 这需要对自己的需求有清晰的认识。

## 用谁的红黑树

确定了数据结构，下一个问题是：自己写还是用现成的？

红黑树的实现并不简单——插入和删除涉及旋转和重新着色，细节容易出错。但这不是一个需要自己写的东西。Igor Sysoev 2002 年写 nginx 的时候就实现了一棵。过去 20 多年里，这棵树在全球数以亿计的连接上经受了考验。后来他写 njs（nginx 的 JavaScript 引擎）时做了一版改进——更灵活、更通用。在我看来，这是最好的红黑树实现。

这棵树最重要的设计特点是**嵌入式节点**——树节点不是一个独立分配的对象，它被直接嵌入到使用者的结构体里。不熟悉编程的读者可以这样理解：假设你要给一堆文件夹按日期排序。一种方式是给每个文件夹做一张索引卡，然后排列卡片——每多一个文件夹就多一张卡。另一种方式是在每个文件夹上直接贴一个标签——标签是文件夹的一部分，不需要额外制作。Sysoev 的设计是后者。添加定时器不需要额外分配内存，删除也不需要释放。**零动态内存分配。**

如果这个模式看着眼熟，那就对了——上一篇里事件对象嵌入到连接对象里就是同样的思路。嵌入式节点是 Sysoev 的一贯风格。

说到这棵树，有段个人经历。在加入 nginx 团队之前，我给 Igor 的红黑树提交过一个小改进。Igor 亲自 review 了，然后合并了。Igor 的代码我读了很多年，能给他的代码贡献一点东西，哪怕很小，比写一千行自己的代码都有成就感。后来加入团队之后更加确认：Igor 对代码质量的要求极高，他愿意合并，说明那个改动是对的。

所以现在把这棵树引入 jsbench，不只是"选了一个好的实现"——我对它的每一行代码都很熟悉。

**好的选型不是选最新的或最流行的，而是选你最理解、最信任的。** 你信任一个实现，意味着你理解它的设计决策、它的边界条件、它在什么情况下会出问题。这种信任不是看了文档就有的，它来自长期的使用和阅读。

## 时间基础函数

有了数据结构，还需要时间的度量。

之前 jsbench 到处裸写系统调用获取时间，没有统一的时间类型，没有封装过的时钟函数。如果定时器模块建在这上面，时间相关的细节就会泄漏到定时器的每一行代码里。

所以引入了一组时间类型——秒、毫秒、纳秒各有自己的类型名，以及三个时钟函数：墙上时钟、单调时钟（用于计算间隔）、本地时间。

这些东西很小——类型定义不到 10 行，函数实现不到 30 行。但它们划定了一个边界：**定时器模块只跟"毫秒"这个抽象打交道，不关心毫秒是怎么从操作系统获取的。** 将来如果要换时钟源、改精度、加缓存，改的是时间层，定时器层不受影响。

这就是分层的意义——不是为了好看，是为了让每一层的变化不波及其他层。

## 定时器模块

红黑树提供排序，时间类型提供度量。定时器模块把它们组装成一个完整的接口：

- **添加** —— 注册一个定时器，x 毫秒后到期
- **删除** —— 取消一个定时器
- **查找** —— 找到最近到期的定时器，返回距离到期还有多少毫秒
- **触发** —— 检查所有已到期的定时器，调用它们的回调

这四个操作就是定时器的全部 API。**对外只露出这四个动作，内部的红黑树操作、时间比较、溢出处理，全部藏在里面。** 使用者不需要知道定时器是用红黑树还是最小堆实现的——这是基础设施该有的样子。

这个模块是独立的——它不知道什么是连接、什么是 epoll、什么是 jsbench。它只知道"有一些定时器，按时间排序，到期了就调回调"。**通用的东西就应该是通用的。**

## 五层结构：单向依赖

这些基础设施加起来，形成了五个独立的层：

```
js_unix.h     ← 操作系统接口
js_clang.h    ← C 语言工具
js_time.h     ← 时间类型和时钟封装
js_rbtree.h   ← 红黑树
js_timer.h    ← 定时器模块
```

每一层只依赖下面的层，不知道上面的层的存在。红黑树不知道什么是定时器，时间类型不知道什么是红黑树，操作系统接口不知道什么是 jsbench。

**依赖方向是单向的，从上往下。**

这是基础设施最重要的性质。如果红黑树依赖了定时器的类型，它就不再是通用的红黑树，而是"定时器专用的红黑树"。如果时间类型引用了连接结构体，它就不再是通用的时间封装。单向依赖保证了每一层的独立性——它可以被任何人使用，不跟特定场景绑定。

这个原则不只适用于 C 语言。无论你用什么语言、做什么项目，基础设施的依赖方向都应该是单向的。数据库工具不应该依赖业务逻辑，日志模块不应该依赖 HTTP 框架。**如果你的基础设施"知道"上层的存在，它就不再是基础设施，而是上层的一部分。**

## 拆头文件：不是提前做，而是刚好做

引入这些基础设施的同时，做了一件之前一直没做的事：拆分头文件。

之前所有声明都在一个 350 行的头文件里。我一直没拆它——不需要。里面全是项目专属的东西，拆开反而要处理包含顺序。一个文件能解决的事，不拆成三个文件——这是第四篇说的"刚好足够"。

但红黑树不一样。它是一个通用数据结构，不属于任何业务逻辑。时间类型也一样。把通用的东西塞进专属的头文件里，就像把数学教材塞进一本小说的目录——它不属于那里。

之前没有理由拆——"将来可能需要"是过度设计的典型起点。现在有了具体需求，方向是清楚的。**重构的最好时机不是"有空的时候"，而是有具体需求的时候。** 需求告诉你该改什么、改到什么程度。没有需求的重构，容易用力过猛。

这也是一个 AI 不会主动做的判断。AI 在项目第一天就会建议你"按职责拆分头文件"。但在只有一个头文件、没有通用组件的时候拆，是过度设计。在引入通用组件之后才拆，是刚好。**时机和内容一样重要。**

## AI 做了什么

这次 AI 做了大量执行工作：照着 Sysoev 的实现适配红黑树，写时间类型和时钟函数，实现定时器的四个接口，拆分头文件。这些加起来近 700 行新代码，涉及 10 个文件。这类工作机械性强、容易出错，正是 AI 的强项。

但关键的判断——用红黑树而不是最小堆、用 Sysoev 的版本而不是自己写、现在拆头文件而不是之前——这些是人做的。

AI 可以在你说出"用红黑树"之后快速写出一个正确的实现。但它不会主动说"用 Sysoev 的版本，因为它的嵌入式设计和 jsbench 的事件模型一脉相承"。它不知道你对这棵树的了解程度，不知道你对 Sysoev 代码的信任程度，不知道这个选择背后有十年的阅读和使用经验。

**选型是人的判断。选型的质量，取决于你的经验、你的品味、你对问题域的理解深度。** 这些不是 prompt 能教给 AI 的。

代码变更: [ca705bf](https://github.com/hongzhidao/jsbench/commit/ca705bf)

到这里，地基打好了。红黑树提供排序，时间类型提供度量，定时器模块提供接口，五个头文件确保每一层干净独立。从功能角度看，jsbench 跑起来和之前完全一样——没有统一任何定时器，没有改 `epoll_wait(100)` 的 100。但所有的基础设施都已就绪。

接下来要做的事是：**把新的基础设施和现有的系统连接起来。**

## 工作引擎：epoll + 定时器 = 一个完整的引擎

地基有了，但它还是散的——红黑树在一边，epoll 在另一边，它们之间没有关系。定时器模块不知道 epoll 的存在，epoll 也不知道定时器的存在。

回到那个 `epoll_wait(100)` 的问题：要让 100 变成"距离最近的定时器还有多久"，epoll 需要向定时器模块查询。这意味着它们必须在某个地方被关联起来。

在哪里关联？答案是：**引入一个新的结构体，把 epoll 和定时器组合成一个整体。**

这就是 `js_engine_t`——工作引擎。

不熟悉编程的读者可以这样理解。一辆车有发动机和仪表盘。发动机负责驱动，仪表盘负责显示时间和速度。它们各自可以独立存在，但只有装在同一辆车里，才能协同工作——仪表盘告诉你"还有 5 公里到目的地"，发动机才知道该加速还是减速。工作引擎就是这辆车：epoll 是发动机（驱动事件），定时器是仪表盘（管理时间），组合在一起才是一个完整的工作引擎。

每个工作线程有一个 engine。engine 创建时初始化 epoll 和定时器，销毁时一起清理。**线程级别的所有基础设施，都归 engine 管。**

引入 engine 的同时，也把 epoll 相关的接口拆分到了独立的 `js_epoll.h` 头文件里。到这里，`js_main.h` 里通用的部分已经陆续拆分出去了——系统接口、语言工具、时间类型、红黑树、定时器、epoll、工作引擎，各自回归各自的模块。`js_main.h` 开始瘦身，从什么都装的大杂烩，逐渐变成只包含 jsbench 项目专属的类型和接口。**当模块多了，让每个模块的声明回到它自己的地方，就是自然的事。**

## 推翻上一篇的决定

有意思的是，引入 `js_engine_t` 意味着推翻上一篇的一个决定。

上一篇把 epoll 的文件描述符（epfd）做成了线程局部变量——每个线程有自己的一份，调用者不需要传递。当时的逻辑是：epfd 是线程级别的基础设施，不是需要传递的参数。

现在 epfd 又变回了需要传递的东西——它在 engine 里面，调用 epoll 操作时要把 engine 传进去。

这是不是自相矛盾？

不是。上一篇消除的是**裸传 epfd**——调用者得自己记住一个整数，传错了编译不报错。现在传的是 **engine**——一个有明确语义的对象，代表"这个线程的工作引擎"。从传一个整数，到传一个对象，抽象级别提高了。

更关键的是，engine 不只有 epfd，它还有定时器。如果继续用线程局部变量，定时器也得做成线程局部的，然后 epoll 和定时器之间的关联又散落在各处。engine 把它们收拢到一起，**相关的东西放在一起，是最基本的组织原则。**

这也说明一件事：**之前的决定不一定是错的，但随着新需求的出现，更好的设计会浮现出来。** 上一篇引入线程局部变量是对的——在当时的上下文里，它解决了 epfd 到处传递的问题。现在引入 engine 也是对的——在新的上下文里，epoll 和定时器需要被组合成一个整体。架构不是一步到位的，它在每一步做当时最合理的选择，随着系统的演进不断调整。

## 聚合：一个实用的重构技巧

`js_engine_t` 用到了一个非常实用的重构模式：**聚合**——把相关的东西放到一个对象里。

这个模式听起来简单到不值一提，但它解决了代码里最常见的一类混乱：**相关的东西散落在各处。**

引入 engine 之前，epoll 和定时器各管各的。epoll 的文件描述符藏在线程局部变量里，定时器的数据结构还没有归属。它们之间的关系是隐含的——"epoll 的超时应该由定时器决定"，这个关系只存在于程序员的脑子里，代码里看不到。

引入 engine 之后，这个关系变成了显式的。epoll 和定时器住在同一个结构体里，它们的关联是代码本身表达的，不是注释、不是文档、不是口头约定。**当相关性被代码表达出来，而不是靠人记住，系统就更不容易出错。**

这个模式的应用远不止 C 语言。在任何项目里，当你发现几个变量总是一起出现——一起创建、一起传递、一起销毁——它们很可能应该被聚合到一个对象里。数据库连接和连接池配置总是一起用？聚合成一个 `DatabaseClient`。用户 ID 和权限列表总是一起传？聚合成一个 `UserContext`。HTTP 请求和它的超时配置总是成对出现？聚合成一个 `RequestOptions`。

聚合不只是"放在一起方便"。它有两个更深层的好处。

**第一，封装。** 散落的东西没有边界，任何人都能直接操作它们。聚合之后，可以通过接口控制访问方式。engine 只暴露 create 和 destroy，内部怎么初始化 epoll、怎么初始化定时器，外面不需要知道。

**第二，生命周期统一。** 散落的东西容易出现"创建了 A 忘了创建 B"、"销毁了 A 忘了销毁 B"的问题。聚合之后，一次 create 全部就绪，一次 destroy 全部清理。**成对的事情放在一起做，就不会忘。**

判断什么时候该聚合，有一个简单的信号：**如果你发现自己在多个地方重复传递同一组参数，或者在多个地方重复同一组初始化/清理步骤，那就是聚合的时机。** 就像这次——worker 和 loop 都要 create epoll、都要 init timers、都要 close epoll，当这个模式重复出现，就该把它们装进一个对象里。

## AI 与重构

引入 `js_engine_t` 这件事，架构判断只用了几分钟——epoll 和定时器应该组合成一个对象，每个线程持有一个。但把这个判断落到代码上，涉及 6 个文件的改动：删掉线程局部变量，新建 engine 的创建和销毁函数，所有 epoll 调用都要加上 engine 参数，worker 和 loop 都要改创建和清理流程。

这类工作交给 AI，它做得非常好——准确地说，是**强到没边**。

AI 在重构方面有一个人类很难匹敌的优势：**它不会漏。** 人工改 20 处函数调用，总有可能漏一处，编译时才发现，或者更糟——编译没报错但运行时出问题。AI 扫一遍代码，所有调用点一次改完，签名对齐、参数一致、没有遗漏。这不是"比人快"的问题，是"比人可靠"的问题。

上一篇也说过类似的话——机械性改动零出错、跨文件保持一致。但这次的体感更强烈。因为这次的改动是**推翻之前的设计**：把线程局部变量改回显式参数。这意味着上一篇 AI 改的那些代码，这次又要被 AI 改回来——不是完全改回去，而是改到一个新的抽象层面上。AI 对此毫无怨言，也不会因为"上次刚改过"就犹豫或者偷懒。它把每次改动都当成一个全新的任务，机械地、完整地执行。

**重构是目前 AI 编程最有价值的场景之一。** 原因很简单：重构的特点是方向明确、改动面广、机械性强——这恰好是 AI 最擅长的。人提供方向（"引入 engine，把 epoll 和 timer 组合起来"），AI 负责把这个方向落到每一个文件的每一行代码上。方向错了，重构就是白做；方向对了，AI 的执行力让你不需要花任何时间在机械性劳动上。

**你的一个架构判断，AI 能帮你落到几十个文件的每一行代码上。判断越准确，杠杆越大。**

代码变更: [8f25458](https://github.com/hongzhidao/jsbench/commit/8f25458)

## 小结

这篇做了两件事。

第一件：打地基。引入红黑树、时间基础函数、独立的定时器模块，形成五层单向依赖的基础设施。功能没变，但所有后续工作的基础就绪了。

第二件：引入 `js_engine_t`，把 epoll 和定时器组合成一个完整的工作引擎。每个线程一个 engine，engine 拥有该线程的全部基础设施。

两件事的主题是一样的：**先搭结构，再做功能。**

`epoll_wait(100)` 的 100 还没有变。三种定时器还没有统一。但现在 engine 同时持有 epoll 和定时器，让 `epoll_wait` 根据最近的定时器动态计算超时——只差最后一步。**当结构对了，功能就是水到渠成的事。**

**地基本身不是目标，但没有它，目标到不了。** 很多人觉得基础设施是浪费时间——"写了半天，功能一点没变"。但好的基础设施让后面的每一步都更简单、更稳固。反过来，如果跳过地基直接写功能，写出来的东西要么是脆弱的，要么是重复的，要么改不动。

这棵红黑树不是我们写的。Igor Sysoev 20 多年前就写好了。**好的架构不只是会设计，还要会选型**——知道什么时候该自己造，什么时候该拿别人造好的来用。如果一个问题已经被最好的工程师用最好的方式解决了，你需要做的不是超越他，而是理解他的设计，然后把它用在正确的地方。

---

GitHub: https://github.com/hongzhidao/jsbench

# 架构是什么，以及它在 AI 时代意味着什么

> 十次重构之后，我对架构有了一个比以前更清晰的理解。

## 一个实验

一个月前我做了一个实验：让 AI 从零写一个 C 项目——用 C + QuickJS 实现的可编程 HTTP 压测工具。两千行，一天就能跑。

然后我花了几周，把它的架构重构了十次。每次写成一篇文章。

这个过程中，我反复在想同一个问题：**到底什么是架构？** 不是教科书上的定义，是在 review 真实代码、做真实决策时，架构这个词到底指的是什么。

十次重构之后，我觉得我比以前更懂这个词了。不是因为读了更多理论，是因为 AI 写的代码给了我一个绝佳的反面教材——它把"没有架构"这件事，展现得比任何教科书都直观。

## AI 的代码教会我什么是架构

AI 写的代码有一个特点：**每个局部都不错，但整体改不动。**

命名准确，前缀一致，测试能过，功能能跑。你挑不出哪个函数写得"差"。但当你想加一个功能、改一个行为的时候，发现牵一发动全身——改这里不知道那里会不会坏，加一个东西要先理解半个系统。

为什么会这样？因为**复杂度是失控的**。

系列第四篇讨论过，架构的本质是管理复杂度。当时那篇偏理论，现在我想用 AI 的代码来具体说明这个道理。

### "装进盒子"到底是什么意思

第四篇说好的架构把复杂度"装进盒子里"——对外简单，对内清晰。

这个说法听起来像正确的废话。但当我看到 AI 写的 `js_fetch.c`，突然理解了"没装进盒子"是什么体感。

AI 的 fetch 实现是一个 400 多行的函数：网络 I/O、DNS 解析、创建独立 epoll 实例、同步等待响应、包装 Promise——全塞在一起。没有分层，没有接口。**五种不同的复杂度搅在同一个函数里。**

结果是：想让 fetch 支持并发，改不动。因为 fetch 自己管着一个独立的 epoll，不接入全局事件循环。要改并发，就得同时动 I/O 模型、Promise 机制、事件循环——因为它们没有被分开，所以只能一起改。

重构之后，fetch 只负责创建连接、注册到全局事件循环、返回一个 pending Promise。事件循环的复杂度在 `js_epoll.c` 里，Promise 的机制在 `js_loop.c` 里，连接管理在 `js_conn.c` 里。每个"盒子"对外只露一个简单的接口。想改并发？只动事件循环那个盒子就够了，其他盒子不需要碰。

**"装进盒子"不是一种比喻。它是一个非常具体的工程动作：让每种复杂度有自己的边界，不跟其他复杂度混在一起。** 做到了，你改一个地方不用担心另一个地方。做不到，你动哪里都怕。

### "隐藏不是转移"到底是什么意思

第四篇还提过一个区分：隐藏复杂度和转移复杂度不是一回事。当时用了"垃圾桶"的比喻。在 AI 的代码里，我看到了更真实的例子。

`js_conn_t`——连接结构体里嵌着一个 `js_http_response_t`，连接层的读函数里直接调 HTTP 解析器，`js_conn_keepalive()` 去读 HTTP 头判断连接复用。

表面上看，HTTP 的逻辑"藏在"了连接模块里。但这不是隐藏，是转移——HTTP 的复杂度被塞进了一个不该承担它的地方。结果是连接层不能离开 HTTP 独立存在，改 HTTP 解析要动连接代码，改连接策略可能碰坏 HTTP 逻辑。**两层的复杂度不是加在一起，是乘在一起。**

重构之后，`js_conn_t` 里没有任何 HTTP 字段。连接层只做传输：建连接、读字节、写字节。HTTP 的解析、keep-alive 判断、响应处理，全在调用方。连接不知道 HTTP 的存在，就像事件引擎不知道连接的存在一样。

**真正的隐藏，是让每个模块只承担自己该承担的复杂度。如果一个模块替别人扛了不属于自己的东西，那不是隐藏，是一颗定时炸弹。**

### "刚好足够"到底是什么意思

第四篇说好的架构在设计不足和过度设计之间：刚好足够，不多不少。

在 AI 的代码里，设计不足随处可见：定时器有三套不同的实现（C-path 用 timerfd，JS-path 用手动比较时间，请求超时逐个遍历），同一件事做三遍；请求概念被拆成两个类型（`js_request_desc_t` 和 `js_raw_request_t`），数据重复、所有权不清。

但在重构过程中，过度设计的诱惑也无处不在。AI 在项目第一天就会建议你"按职责拆分头文件"——可当时只有一个头文件，没有通用组件，拆了是过度设计。后来引入红黑树和定时器模块，它们不属于任何业务逻辑——这时候拆才是刚好需要。

**"刚好"不是一种设计能力，是一种时机判断。** 同一个动作，做早了是过度设计，做晚了是设计不足。什么时候做，取决于你当下对系统的理解——而理解是在解决问题的过程中不断加深的。

这也是为什么好的架构不是设计出来的，是一步步长出来的。jsbench 十次重构没有一次是提前计划的——每解决一个问题，才看到下一个问题。想封装 `epoll_wait`，发现 `epfd` 是个依赖；消除了 `epfd`，发现 conn 耦合在事件循环里；解了耦合，`js_epoll_poll()` 才水到渠成。

## AI 时代，架构的价值被放大了

以上都是架构的本质——无论有没有 AI，这些道理都成立。但 AI 让架构的价值发生了一个质变。

为什么？因为 AI 改变了一个关键的经济学：**写代码的成本趋近于零，但管理复杂度的成本没有变。**

在 AI 之前，写代码是瓶颈。想法很多，但写出来要时间。所以"能把想法变成代码"本身就是一种稀缺能力。

现在 AI 能写代码了。一天两千行 C 代码，能跑，能测，命名合理。写代码不再是瓶颈。

那什么成了瓶颈？

**复杂度。**

AI 写代码的速度远快于人类。但代码量越多，复杂度越高。如果没有架构来管理复杂度，AI 写得越快，系统就越快变成一团无法维护的意大利面。

这就是我在 jsbench 上看到的。AI 一天写出两千行能跑的代码。但复杂度失控了：连接层嵌着 HTTP 解析器，fetch 是伪异步，定时器三套实现，请求类型拆成两个。功能都能跑，但代码改不动。

**AI 极大地降低了生产代码的成本，但同时也极大地加速了复杂度的产生。** 如果没有架构来约束，AI 就是一台高效的技术债生成器。

反过来说：**如果架构做好了，AI 就是你的整个团队。**

我告诉 AI "fetch 应该返回 pending Promise，I/O 由全局事件循环驱动"——它一次改对了，9 个文件。我说"每个线程有且只有一个 epoll"——它立刻用 thread-local 存储重写了所有接口。我说"这个字段不该在 conn 里，它属于一个叫 http_peer 的新概念"——它创建了新结构体，搬移了字段，更新了所有引用。

每一次，AI 的执行都是完美的。它不会漏改、不会改错签名、不会忘记更新调用方。6 个文件 20 多处修改，一次做完。

但每一次的前提都是：**我给了它一个正确的方向。**

方向来自哪里？来自对架构的理解。知道什么是对的分层，知道依赖该往哪个方向走，知道复杂度该被藏在哪里。

**架构是让 AI 有效工作的前提条件。** 没有架构方向，AI 只能在原地打转——它会给你列出几种方案，但不会替你拍板。有了架构方向，AI 就是一台精确的执行机器。

所以在 AI 时代，架构的价值不是"有了更好"，而是**必须有**。代码可以让 AI 写，但架构不行——因为架构决定了 AI 写的代码是资产还是负债。

## 四个基本动作

十次重构，反复用到四个动作。它们不是系统编程专属的，适用于任何管理复杂度的场景。

**定义边界。** 用抽象划出一条线——线以上所有东西一视同仁，线以下各自不同。jsbench 的事件引擎就是这样：连接是事件，定时器也是事件，分发逻辑不关心区别，只调 handler。新增事件类型不需要改分发代码。这是系统能扩展的根本原因。

**消除依赖。** 如果一个东西是基础设施，就不该让每个人都扛着它跑。epoll 的文件描述符是线程的属性，不是需要传递的参数。接口少一个参数，不只是少打几个字——是从源头消除了传错的可能。

**解开耦合。** 不是绕过问题，是让每个模块的逻辑回到它自己内部。连接层不该知道 HTTP，事件引擎不该知道连接。当你想封装一个函数但发现改不动，往往是因为某处耦合挡着——先解耦，再封装。

**隐藏复杂度。** 把实现细节装进盒子里，对外只露简单的接口。`epoll_wait()` 从散落在两个文件变成只在 `js_epoll_poll()` 里出现。复杂度不会消失，但它可以被隔离，不蔓延到系统各处。

这四个动作的共同本质是：**管理复杂度。** 定义边界是划定复杂度的范围，消除依赖是减少复杂度的传导路径，解开耦合是阻止复杂度的相互叠加，隐藏复杂度是让它不蔓延。

当你觉得代码"改不动了"——无论是你自己的代码还是 AI 写的代码——往往是这四个方向中的某一个没做好。

## AI 时代的迭代经济学

还有一件事值得说：AI 改变了迭代的经济学。

以前重构一次，一个资深工程师可能要花一天。十次重构，两周。很多时候你心里知道代码不够好，但改的成本太高，就忍了。技术债就是这么来的。

现在呢？给 AI 讲清楚方向，一次重构几分钟。它不会因为"上次刚改过"就犹豫，不会改了接口忘了调用方，不会 20 处修改漏一处。

**以前你负担不起的架构改进，现在负担得起了。**

这意味着什么？意味着 **"刚好足够"的标准可以更高了。** 以前因为改动成本太高而容忍的"差不多"，现在可以做到真正的"刚好"。那些以前记个 TODO 就搁置的不合理——多余的依赖、模糊的边界、不该在这里的字段——现在可以随时修正。

**AI 让架构演进变成了一件可以持续做的事，而不是一件"等有空再说"的事。**

这是 AI 对编程方式最深刻的改变。不是"AI 能写代码了"——那只是表象。真正的改变是：**好架构的门槛降低了。** 以前只有大公司的核心项目才负担得起持续的架构优化。现在一个人加一个 AI，就可以做到。

但迭代成本降低了，迭代方向还是你的事。

## 什么能力在升值

说到这里，回答一个很多人在问的问题：**AI 时代，程序员的核心能力是什么？**

**架构判断。** AI 能帮你实现任何方向，但不会帮你选方向。代码怎么组织、模块怎么拆、抽象放在哪一层、复杂度该藏在哪里——这些决策决定了 AI 写的代码是资产还是负债。你的一个架构判断，AI 能落到几十个文件的每一行代码上。判断对了，是几十倍的杠杆。判断错了，也是几十倍的杠杆。

**Code Review。** AI 写代码的速度远快于人，bug 产出的速度也远快于人。能看出代码哪里不对——不是语法错误，是逻辑和架构层面的问题——这个能力在 AI 时代不是锦上添花，是**防线**。AI 写的代码和 AI 写的测试有一致的盲区，这个我有切身体会。

**领域深度。** 我能判断 fetch 该用事件循环而不是同步阻塞，不是因为 prompt 写得好，是因为写了十几年事件驱动程序。AI 放大的是你已有的能力，不是凭空创造能力。你在某个领域越深，AI 给你的杠杆越大。

**重构的能力。** Martin Fowler 的《重构》，或者 Joshua Kerievsky 的《重构与模式》。重构是 AI 时代最有价值的编程活动——方向明确、改动面广、机械性强，恰好是 AI 最擅长的。你负责识别问题和判断方向，AI 负责把改动落到每一行代码上。

至于"写代码"本身？它的权重在下降。不是不需要，是它不再是瓶颈了。**瓶颈从"怎么把想法变成代码"变成了"怎么管理代码产生的复杂度"。** 而管理复杂度，就是架构。

## 最后

回到最初的定义：**架构是管理复杂度的方式。**

在 AI 之前，这句话意味着：好的架构让团队协作更高效、让维护成本更低。重要，但不是生死攸关。

在 AI 之后，这句话的分量变了：**架构是让 AI 生产力不变成破坏力的唯一屏障。**

AI 能写所有代码。但写代码不是目的，管理复杂度才是。AI 越能写代码，复杂度的产生速度就越快，架构的价值就越大。

这是一个反直觉的结论：**AI 让写代码变得越容易，架构就变得越重要。** 不是更不重要——是更重要。

程序员的未来不是写代码，是做判断。判断什么是对的方向，判断代码哪里不对劲，判断复杂度该藏在哪里。然后让 AI 把判断落到每一行代码上。

判断力来自架构理解、领域深度和持续的实践。这些东西没有捷径。

但好消息是，AI 让你的每一分判断力都变得更有价值了。

---

*本文基于「一个 nginx 工程师接手了 AI 的压测工具」系列的十篇实战文章。完整系列从代码组织到事件引擎、从连接分层到结构体设计，记录了完整的架构重构过程。每篇都有对应的代码变更链接。*

GitHub: https://github.com/hongzhidao/jsbench

更多文章，关注微信公众号：**程序员洪志道**

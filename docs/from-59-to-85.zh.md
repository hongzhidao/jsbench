# AI 代码评分 59，我没手写一行代码，把它改到了 85

> 两千行 C 代码，AI 一天写完，能跑。然后我花几周重构架构，没手写一行代码，全程指导 AI。评分从 59 涨到 85。涨的不是功能，是架构。

我在 nginx 团队工作，最近做了一件事：让 AI 从零写一个 C 项目——可编程的 HTTP 压测工具 [jsbench](https://github.com/hongzhidao/jsbench)——然后在不手写任何代码的前提下，纯粹通过指导 AI 来重构它的架构。

完成后，我对两个版本做了逐维度评分：

| 维度 | AI 版 (v1) | 重构后 | 满分 | 变化 |
|------|-----------|--------|------|------|
| 异步架构设计 | 7 | 14 | 15 | **+7** |
| 内存安全 | 7 | 11 | 15 | +4 |
| 抽象质量 | 5 | 9 | 10 | +4 |
| 可维护性/可扩展性 | 4 | 7 | 10 | +3 |
| 代码组织 | 5 | 8 | 10 | +3 |
| 构建系统 | 5 | 8 | 10 | +3 |
| 正确性 | 6 | 7 | 10 | +1 |
| 可读性/风格 | 8 | 8 | 10 | 0 |
| 健壮性 | 4 | 5 | 5 | +1 |
| 功能完整度 | 8 | 8 | 10 | 0 |
| **总分** | **59** | **85** | **105** | **+26** |

26 分的差距。功能完整度和可读性没变——AI 本来就做得好。涨的全是架构维度：异步设计、抽象质量、可维护性、代码组织。

这篇不讲"AI 能不能写代码"——能，而且写得不错。我想聊的是：**这 26 分到底是怎么挣来的，以及为什么只有人能挣到这些分。**

## 涨 7 分的异步架构：方向对了，AI 一次改对

最大的涨幅来自异步架构，从 7 分涨到 14 分。

AI 的第一版 `fetch()` 是这样的：400 多行函数，自己创建一个独立的 epoll 实例，自己发请求、自己阻塞等响应、自己拼 Promise——看起来像异步，实际上是同步阻塞。表面返回 Promise，内部一直等到请求完成才返回。

```js
// 三个 300ms 的请求
const [a, b, c] = await Promise.all([
    fetch(url1), fetch(url2), fetch(url3)
]);
// 理论 300ms，实际 905ms——串行了
```

这不是某个函数写错了。是整个 I/O 模型就不对。

我给 AI 的方向是：**fetch 不要自己管事件循环。创建连接，注册到全局事件循环，返回一个 pending Promise。I/O 由全局事件循环统一驱动。**

AI 一次改对了。涉及 9 个文件的改动，905ms 变 302ms。

为什么 AI 自己做不到？因为这不是一个代码层面的问题。AI 的每一行代码都是对的——DNS 解析对的，socket 创建对的，HTTP 序列化对的，Promise 包装对的。问题在于这些"对的"代码被组织在了一个"错的"架构里。**AI 缺的不是写代码的能力，是判断"这些代码应该怎么组织在一起"的能力。**

而这个判断来自经验。我能一句话给出方向——"全局事件循环 + pending Promise"——是因为在 nginx 团队长期做事件驱动架构。这不是 prompt 技巧，是领域深度。

**你在某个领域越深，AI 给你的杠杆越大。** 这是整个旅程最核心的体会。

## 涨 4 分的抽象质量：不是缺代码，是缺概念

AI 的代码里缺了什么？

不是缺功能——功能都能跑。不是缺代码——代码量够。是缺概念。

### 没有"事件"这个概念

AI 用 NULL 指针区分事件类型——注册到 epoll 时，定时器传 NULL，连接传连接指针。分发的时候先检查是不是 NULL：

```c
if (events[i].data.ptr == NULL) {
    // 定时器
} else {
    js_conn_t *c = events[i].data.ptr;
    // 连接
}
```

加一种新事件类型就要加一层 if-else。这不是可扩展的设计。

重构后，引入了 `js_event_t`——每个事件自带处理函数：

```c
typedef struct {
    int                   fd;
    void                 *data;
    js_event_handler_t    read;
    js_event_handler_t    write;
    js_event_handler_t    error;
} js_event_t;
```

分发变成：`if (ev->read) ev->read(ev)`。不关心事件是什么，只管调 handler。加新事件类型，分发代码一个字不用改。

### 没有"一次 HTTP 交互"这个概念

请求计时 `start_ns` 存在连接对象里。HTTP 响应解析器通过 `conn->socket.data` 间接访问。一次请求的状态散在两个地方，靠隐式约定关联。

引入 `js_http_peer_t` 后：

```c
typedef struct {
    js_http_response_t  response;
    uint64_t            start_ns;
} js_http_peer_t;
```

两个字段归到一起，因为它们属于同一个概念。连接层立刻变干净了——它不再替 HTTP 层保管数据。

### 没有"一次 fetch 操作"这个概念

`js_loop_add()` 有六个参数：连接、TLS 上下文、JS 上下文、resolve 回调、reject 回调、loop 指针。loop 在函数内部分配结构体、初始化 HTTP 解析器、设超时、注册事件。一个事件循环，干着 HTTP 客户端的初始化。

为什么？因为代码里没有一个类型表达"一次 fetch 操作是什么"。

引入 `js_fetch_t` 后，六个参数变两个。分配和初始化回到 `js_fetch()` 里。超时处理回到 fetch 模块。loop 从 224 行变成 85 行纯调度器。

**每次引入一个正确的概念，一连串的代码就自然变简洁了。** 不是删了代码，是代码找到了它该在的位置。

AI 不会主动发现缺失的概念。它把数据放在最方便的地方——哪里要用就放哪里。但"方便"和"正确"不是一回事。识别"这里缺一个概念"，是人的工作。

## 涨 3 分的可维护性：从"改不动"到"随便改"

AI 第一版的架构长这样：

```
           jsb.h（318 行，所有声明）
                  │
   ┌──────────────┼──────────────┐
   │              │              │
fetch.c      worker.c     http_client.c
544 行        239 行         227 行
同步阻塞      事件分发        conn + HTTP
+ Headers     + conn 处理     混在一起
+ Response    + HTTP 解析
+ fetch()     + 统计
```

一个头文件装所有声明。每个文件都知道其他文件的事。改一处可能影响所有地方。

重构后：

```
┌──────────────────────────────────────────┐
│  应用层                                    │
│  js_worker.c  js_fetch.c  js_loop.c       │
├──────────────────────────────────────────┤
│  HTTP 层                                   │
│  js_http.h  js_http_parser.c              │
│  js_headers.c  js_response.c              │
├──────────────────────────────────────────┤
│  连接层                                    │
│  js_conn.h  js_conn.c  js_buf.h           │
├──────────────────────────────────────────┤
│  引擎层                                    │
│  js_engine.h  js_epoll.h  js_timer.h      │
├──────────────────────────────────────────┤
│  基础设施                                   │
│  js_unix.h  js_clang.h  js_rbtree.h       │
└──────────────────────────────────────────┘

依赖方向：↓ 只往下，不往上
```

5 层。每层只依赖下面的层，不知道上面的存在。引擎不知道连接，连接不知道 HTTP，loop 不知道 fetch 的具体实现。

**改任何一层，不影响其他层。** 这就是"可维护"的含义——不是代码写得好看，是改一个东西不用担心另一个东西坏。

从 13 个文件到 32 个文件。代码总量从 2800 行到 3900 行。每个文件变小了，每个模块只做一件事。多出来的主要是基础设施——红黑树定时器、buffer 抽象、事件引擎——这些不是膨胀，是把原来隐含的复杂度显式地管理起来了。

## 不变的两个分数：AI 本来就做得好的地方

功能完整度 8/10、可读性 8/10——这两项重构前后没有变化。

AI 的命名几乎无可挑剔。十三个源文件上百个函数，`js_` 前缀没有一处遗漏。在 C 这种没有命名空间的语言里，这种一致性比很多人类项目都好。编程界公认命名是难题，但对连自然语言都能处理的模型来说，给变量函数起个准确的名字反而是最轻松的部分。

AI 每个函数的实现也很直接——没有炫技，没有过度抽象，就是最直白地把事情做了。有时候我觉得某段代码可以写得"更优雅"，仔细想想，那个"优雅"可能只是我的审美偏好，不是真正的改进。

**AI 迫使我区分"真正的架构问题"和"个人审美偏好"。** 前者必须改，后者可以不改。这个区分能力，反过来也帮我做出了更精准的架构判断。

## 26 分差距背后的方法

回头看，所有改动用到的手法其实不多，但反复生效。

### 用约束代替方案

AI 卡住不是因为它不会写，是不知道往哪个方向走。这时候不要给它具体方案，给它一个约束。

- "每个线程有且只有一个 epoll" → AI 立刻用 thread-local 存储重写了所有接口
- "连接不知道 HTTP 的存在" → AI 从 conn 里删掉了所有 HTTP 字段，更新了所有引用
- "fetch 不要自己管事件循环" → AI 重写了整个 I/O 模型

约束比方案好在哪？方案解决一个问题，约束定义一个方向。AI 拿到约束之后，能自己推导出所有具体的改动。**一句准确的约束，AI 能帮你落到几十个文件的每一行代码上。**

### 一次只改一层

想封装 `epoll_wait()` 成一个干净的函数，但发现连接的后处理逻辑散在事件循环里，拆不开。如果硬改，就是在耦合的代码上叠加更多耦合。

所以先把连接的处理逻辑收回连接模块（解耦），然后再封装 `epoll_wait()`（隐藏）。分开做，每一步都小，每一步测试都过。

类似的事情反复发生。想理清 HTTP 层，发现请求类型有两个（描述和序列化分开存的），先合并请求类型，再理 HTTP。想让 loop 变干净，发现 fetch 的行为混在 loop 里，先把行为搬回 fetch，loop 才变成 85 行。

**不是想不到最终目标——是中间有障碍。看到障碍在哪、先解决障碍，是架构判断的一部分。**

### 用类型表达理解

当你觉得代码哪里不对劲但说不清为什么，问自己一个问题：**"这个字段为什么在这个结构体里？"**

逐个字段检查：它描述的是这个类型所代表的概念吗？还是它其实属于别的东西，只是恰好放在了这里？

如果答案是后者，要么缺少一个概念，要么概念的边界画错了。给它一个名字、一个结构体，很多问题就自然消失了。

nginx 的 `ngx_connection_t` 不知道 HTTP 的存在，Linux 内核的 `struct sock` 不知道 TCP 的存在。好的代码库里，类型定义本身就是最好的架构文档。

## 最危险的一分

正确性只涨了 1 分（6→7）。但这 1 分背后的故事最值得讲。

修完并发之后，测试全过。我继续 review，发现 bench 模式下每次 fetch 都失败了——**16576 次请求，全部失败。**

但测试报告：16576 次请求，0 错误，通过。

原因：代码把每次调用无条件计入"成功"，测试只看这个数字。

**AI 写的代码不检查错误，AI 写的测试不验证错误。** 实现和测试是同一个模型生成的，它们有一致的盲区——完美地互相配合，制造了"一切正常"的假象。

从任何一边单独看都没问题。只有人从外部 review，才能打破这个闭环。

这件事让我确信一点：**AI 越能写代码，review 越重要。** 不是更不重要——是更重要。因为产出速度更快了，如果没有 review，bug 堆积的速度也更快了。

## 这些分数说明了什么

回头看评分表，一个规律很清楚：

**AI 擅长的维度（可读性、功能完整度）几乎不需要人的干预。** 让它自由发挥，8/10。

**AI 不擅长的维度（异步架构、抽象质量、可维护性）需要人给方向。** 没有方向，4-7 分；有了方向，7-14 分。

差距不在代码质量——AI 的代码质量是过关的。差距在架构质量——代码怎么组织、概念怎么表达、复杂度怎么隔离。

这意味着什么？

**如果你只用 AI 写代码然后就交付了——你拿到的是 59 分的产物。** 能跑，但改不动。功能都在，但加新功能要理解半个系统。

**如果你在 AI 写完之后做一轮架构审查和重构——分数可以大幅提升。** 而且这个重构本身也可以让 AI 来做。你只需要给方向。

用一句话说：**AI 把"写代码"的成本打到了极低，但同时也把"管理代码复杂度"的价值推到了极高。** 管理复杂度就是架构。在 AI 时代，架构不是锦上添花，是必须有。

## 如果你也想试

**拿到 AI 代码后，先看架构维度。** 功能能不能跑、命名好不好——这些 AI 通常做得不错。把注意力放在评分表里涨幅最大的维度：模块之间的依赖方向对不对、该有的概念有没有被表达成类型、复杂度有没有被隔离。这些是 AI 最容易丢分的地方，也是你介入后提升最大的地方。

**给约束，不给方案。** 不要告诉 AI "把这个函数拆成三个"。告诉它 "这一层不应该知道上面那一层的存在" 或者 "这几个参数其实是同一个概念，应该用一个类型表达"。约束定义方向，AI 自己能推导出所有具体改动。

**一次只解决一个问题。** 想封装一个模块，发现另一处耦合挡着，那就先解耦，下一步再封装。每一步跑测试确认没坏。十次小重构比一次大重构安全得多。

**Review 测试本身，不只是跑测试。** 16576 次全失败报 0 错误——这件事说明 AI 写的测试和代码有一致的盲区。确保测试验证的是真正的结果，不只是"有输出"。

---

**延伸阅读：**

- 这些分数背后的架构原则，我写了一篇更系统的思考 → [架构是什么，以及它在 AI 时代意味着什么](architecture-in-ai-era.zh.md)
- 完整的实战过程 → [一个 nginx 工程师的 AI 实战：从有代码到有架构](the-journey.zh.md)

十篇系列文章记录了完整的重构过程，每篇都有对应的代码变更链接。

---

GitHub: https://github.com/hongzhidao/jsbench

更多文章，关注微信公众号：**程序员洪志道**

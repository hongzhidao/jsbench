# 一个 nginx 工程师的 AI 实战：从有代码到有架构

> 没有手写一行代码。全程是跟 AI 讨论、给方向、review、再讨论。这篇是整个过程的记录。

我在 nginx 团队工作。最近做了一件事：让 AI 从零写一个完整的项目，然后在不手写任何代码的前提下，纯粹通过指导 AI 来重构它的架构。

这个过程我写了十篇文章，基本都是关于架构的。这篇是故事的完整版。

## 为什么做这件事

压测工具这个东西，做后端的都用过。wrk 性能好但脚本用 Lua，k6 用 JS 但装完几十 MB 还得学一套自定义 API。我想要的很简单：wrk 的性能，标准的 JS fetch API，零学习成本。

这种东西正好适合让 AI 来写——需求清晰，技术栈明确，规模不大。但我有一个私心：**我想看看 AI 独立写出来的代码到底长什么样。** 所以我没有提前跟它讲架构，先让它自由发挥。

## AI 写完，我惊讶了两次

第一次惊讶：**它真的能跑。**

两千行 C 代码，能编译，能跑，测试通过。命名准确，前缀一致——十三个源文件上百个函数，没有一处遗漏。在 C 这种没有命名空间的语言里，这个纪律性比很多人类项目都好。

第二次惊讶：**看完整体之后，说不清哪里不对，但就是不舒服。**

每个函数独立看都没问题。但文件之间的关系、模块之间的边界、依赖的方向——没有整体设计。所有东西都能跑，但你感觉它们不是被"设计"在一起的，是被"堆"在一起的。

后来我想明白了：**AI 写的代码像一栋没有图纸的房子——每面墙砌得都不错，但你走进去会迷路。** 这就是"有代码没架构"的体感。

于是我开始重构。规则只有一条：**不手写任何代码。** 所有改动都通过跟 AI 讨论来完成——我提出问题、给方向、review 结果、纠正细节。

## 方向对了，AI 的执行力是惊人的

重构中碰到的第一个真问题：fetch 不支持并发。三个 300ms 的请求用 `Promise.all` 发，理论 300ms，实际 905ms——串行了。AI 用了"伪异步"：签名返回 Promise，内部同步阻塞。

我把正确的方向告诉它——全局事件循环 + pending Promise——**它一次改对了，9 个文件，905ms → 302ms。**

如果我只说"fetch 有 bug"，AI 大概会在原架构上缝补。因为我能给出明确的架构方向，它才一步到位。

**不是 AI 的能力变了，是我给的方向变了。** 同一个 AI，你给的方向不同，产出可以天差地别。这是整个旅程里最核心的体会。

## 最危险的 bug：一切看起来正常

但紧接着就碰到了最让我震动的事。

修完并发，测试全过。我继续 review 代码，发现 bench 模式的 worker 线程里根本跑不起 fetch。**每一次请求都失败了。**

但测试报告：**16576 次请求，0 错误，通过。**

原因：代码把每次调用无条件计入"成功"，测试只看这个数字。

**AI 写的代码不检查错误，AI 写的测试不验证错误。它们有一致的盲区——完美地互相配合，制造了"一切正常"的假象。**

这不是偶然。实现和测试是同一个模型生成的，盲区是一致的。你从任何一边都看不出问题。**只有人从外部 review，才能打破这个闭环。**

我告诉 AI 问题在哪，它几分钟就修好了。发现问题靠人，解决问题靠 AI。这个分工后来贯穿了整个旅程。

## 一句话的力量

重构越往深走，越能感受到一种奇特的反差。

有一次我想把事件引擎封装成一个干净的接口。AI 卡住了——不是不会写，是不知道该往哪个方向走。代码里好几个问题纠缠在一起，它能看到每个问题，但给的方案要么是绕过去，要么是把问题挪个位置。折腾了好几轮，没有进展。

然后我说了一句话：**"每个线程有且只有一个 epoll。"**

就这一句。AI 立刻知道该怎么做了——用 thread-local 存储，重写所有 epoll 接口，去掉每个调用点的 fd 参数。涉及十几处分散在不同文件的修改，一次做完，编译零警告。

类似的事情反复发生。我说"这个字段不该在 conn 里，它属于一个叫 http_peer 的新概念"——AI 创建新结构体，搬移字段，更新所有引用，6 个文件 20 多处改动，没有一处遗漏。我说"把 epoll 和定时器组装成一个工作引擎"——它改了十几个文件，签名对齐、参数一致、调用方全部更新。

人工做这种改动，20 处修改总有可能漏一处。AI 不会。

**但每一次的前提都是：我给了它一个准确的判断。** 没有那句话，AI 在原地打转。有了那句话，它比任何人类工程师都执行得更快更可靠。

这让我想明白了一件事：**AI 有架构知识，但缺乏架构判断。** 它知道所有的设计模式和技术手段。但面对一团纠缠的代码，它不会说"先改这个，这个解决了那个才能动"。它更倾向于列出几种方案，把选择权交给你。

**你的一个判断，AI 能帮你落到几十个文件的每一行代码上。判断越准确，杠杆越大。**

## 跟 AI 学到的东西

这个过程不全是我在教 AI。有些时候，AI 的做法让我反思自己的习惯。

比如命名。编程界公认的难题。但 AI 起名字几乎不犹豫——连自然语言都能处理的模型，给变量函数起个准确的名字反而是最轻松的部分。这让我意识到，命名之所以对人类难，不是因为它本身难，是因为人脑同时在处理太多东西，命名的注意力被挤压了。

再比如一致性。上百个函数，前缀没有一处遗漏。人工写这么多代码，总有状态不好的时候。AI 不会。**机械性的一致性，AI 天然比人类可靠。**

还有一个更深的体会。AI 的代码虽然缺少架构，但每个函数的实现是**直接的**——没有炫技，没有过度抽象，就是最直白地把事情做了。有时候我觉得某段代码可以写得"更优雅"，但仔细想想，那个"优雅"可能只是我的审美偏好，不是真正的改进。**AI 迫使我区分"真正的架构问题"和"个人审美偏好"。** 前者必须改，后者可以不改。这个区分能力，对架构判断非常重要。

## 推翻自己也是常态

有一次我推翻了自己上一步的设计。上一步刚把某个参数做成了线程级别的隐式变量，下一步就改回了显式传递——因为新的需求出现了，更好的抽象浮现了。

**之前的决定不是错的。是随着系统演进，更好的设计浮现了。** 架构不是一步到位的——每一步做当时最合理的选择，随时准备在新的认知下调整。

AI 对推翻之前的设计毫无怨言。上次的代码它改的，这次推翻它也改。**人会有沉没成本心理，AI 没有。** 这一点在重构中特别有用——你永远可以说"之前那个方案不够好，换一个"，AI 不会有任何抵触。

## 缺的不是功能，是概念

最后一个阶段，回到了最本质的问题：**代码里缺了什么。**

不是缺功能——功能都能跑。是缺概念。

请求计时为什么散在连接结构体里？因为代码里没有"一次 HTTP 交互"这个概念。一个函数为什么要传六个散装参数？因为代码里没有"一次 fetch 操作"这个概念。

**当你觉得代码哪里不对劲但说不清为什么，往往是某个概念应该存在但还没有被表达出来。** 给它一个名字、一个结构体，很多问题就自然消失了。

AI 不会主动发现缺失的概念。它把数据放在最方便的地方——哪里要用就放哪里。但"方便"和"正确"不是一回事。

不过一旦你告诉它缺什么，它创建结构体、搬移字段、更新所有引用的速度和准确性，远超人工。

## 一些实用建议

**用最强的模型。** AI 本质上是一个智能工具，智能水平直接决定产出质量。架构级的改动需要理解上下文、保持跨文件一致、做出合理的实现选择——模型越强，做得越好。我全程用的是能用到的最强模型，体感差别非常大。

**做重构用手动确认模式。** AI agent 通常有全自动和手动确认两种模式。重构涉及架构判断，经常需要临时调整方向——想改 A 发现要先改 B。全自动模式下 AI 会硬着头皮往错误的方向走下去。手动确认让你在每一步都能把关和调整。

**让 AI 写测试，但人要 review 测试本身。** 测试仍然是保证代码质量的最好方式。关键是确保测试验证的是对的东西——不只是"能跑"，而是"结果是对的"。

**实践，实践，实践。** 架构能力没有捷径。不是写更多的代码，是写完之后回头看——这个结构真的对吗？这些字段真的属于这里吗？这个模块的边界在哪？现在 AI 把重构的成本打到了极低，**你可以比以前任何时候都更频繁地练习架构。** 以前改一次架构要花很久，现在跟 AI 说清楚方向就行了。这意味着同样的时间，你可以做更多次"发现问题 → 想方向 → 改 → 验证"的循环。每一次循环都在打磨你的判断力。

**多读好的代码。** 我的架构判断很大程度上来自阅读 nginx、njs 这些项目的源码。好的代码库里，一个结构体的定义本身就是一份领域模型的文档。看它们怎么划分概念边界，比看设计模式的书直接得多。

**深耕一个领域。** AI 是放大器。你在某个领域越深，AI 给你的杠杆越大。选一个方向，花几年时间真正搞懂它。深度是 AI 时代最稀缺的东西。

**参与专业的项目，学习高质量的代码，和专业的人交流。** 我的架构判断不是自己悟出来的，是在 nginx 团队跟顶级工程师一起工作磨出来的。看 Igor Sysoev 怎么设计一棵红黑树、怎么抽象事件模型、怎么用一个结构体表达一个完整的概念——这些东西读文档学不会，要在真实项目里浸泡。如果有机会参与高质量的开源项目或者跟比你强的人一起工作，那是最快的成长路径。AI 能放大能力，但能力本身的来源是人和项目。

## 这段旅程让我想清楚的事

十篇文章，每篇都有对应的代码变更。没有手写一行代码，全部通过指导 AI 完成。核心架构完全重做，功能没变，每次改动后测试全过。

几个体感最深的认识：

**写代码不再是瓶颈，管理复杂度才是。** AI 能写两千行能跑的代码。但这些代码的复杂度是失控的——能跑，改不动。管理复杂度就是架构。AI 时代，架构的价值不是降低了，是**被放大了**。

**方向是最大的杠杆。** 你的方向有多准确，AI 的杠杆就有多大。方向来自经验和领域深度——我能判断 fetch 该用事件循环、定时器该用红黑树、连接层不该知道 HTTP，是因为在这个领域工作了很多年。**AI 放大的是你已有的能力，不是凭空创造能力。**

**Review 是防线。** 16576 次全失败、报告 0 错误——这件事我不会忘。AI 写的代码和测试有一致的盲区，只有人能从外部打破。

**不手写代码是可行的，而且可能是更好的工作方式。** 我发现问题 → 想清楚方向 → 告诉 AI → review 结果 → 纠正细节。这个循环让我把全部精力放在了判断上，而不是实现上。**判断力才是核心资产。**

完整系列：[一个 nginx 工程师接手 AI 写的软件](https://www.zhihu.com/column/c_2003830990213239603)

**延伸阅读：**

- 后来我对两个版本做了逐维度评分，差距比预想的大 → [AI 代码评分 59，我没手写一行代码，把它改到了 85](from-59-to-85.zh.md)
- 重构之后，对架构有了更系统的思考 → [架构是什么，以及它在 AI 时代意味着什么](architecture-in-ai-era.zh.md)

---

GitHub: https://github.com/hongzhidao/jsbench

更多文章，关注微信公众号：**程序员洪志道**
